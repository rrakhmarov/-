НОМЕР 1 Python:
import numpy as np

# Определение коэффициентов системы уравнений
A = np.array([
    [-5, -6, 4, -2],
    [0, 3, -4, -6],
    [2, 4, -4, 2],
    [1, -8, 2, 8]
])

# Определение вектора правых частей
b = np.array([-64, -55, -48, 68])

# Решение системы методом Гаусса
x = np.linalg.solve(A, b)

# Вывод решения
print("Решение системы:")
print(x)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
НОМЕР 2 Python:
import numpy as np

# Определение коэффициентов системы уравнений
A = np.array([
    [5, 2, -2],
    [3, -3, -1],
    [2, 3, -1]
])

# Определение вектора правых частей
b = np.array([0, 1, -1])

# Решение системы методом Гаусса-Жордана
def gauss_jordan(A, b):
  """
  Функция для решения системы линейных уравнений методом Гаусса-Жордана.

  Args:
    A: Матрица коэффициентов системы уравнений.
    b: Вектор правых частей системы уравнений.

  Returns:
    Вектор решений системы уравнений.
  """
  n = A.shape[0]

  # Приведение матрицы к ступенчатой форме
  for i in range(n):
    if A[i, i] == 0:
      # Перестановка строк
      for j in range(i + 1, n):
        if A[j, i] != 0:
          A[i], A[j] = A[j], A[i]
          b[i], b[j] = b[j], b[i]
          break

    # Деление строки на ведущий элемент
    A[i] /= A[i, i]
    b[i] /= A[i, i]

    # Вычитание строк
    for j in range(i + 1, n):
      A[j] -= A[j, i] * A[i]
      b[j] -= b[j, i] * b[i]

  # Приведение ступенчатой матрицы к диагональной форме
  for i in range(n - 1, -1, -1):
    for j in range(i):
      A[j] -= A[j, i] * A[i]
      b[j] -= b[j, i] * b[i]

  # Вычисление решений
  x = np.zeros(n)
  for i in range(n):
    x[i] = b[i]

  return x

# Решение системы
x = gauss_jordan(A.copy(), b.copy())

# Вывод решения
print("Решение системы:")
print(x)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
НОМЕР 3 C++:
#include <iostream>
#include <iomanip>

using namespace std;

void seidel(double a[][4], double x[], double b[], int n, double eps) {
  int i, j;
  double temp;

  for (int it = 0; it < 1000; it++) {
    for (i = 0; i < n; i++) {
      temp = 0;
      for (j = 0; j < n; j++) {
        if (j != i) {
          temp += a[i][j] * x[j];
        }
      }
      x[i] = (b[i] - temp) / a[i][i];

      // Проверка на сходимость
      if (abs(x[i] - old_x[i]) < eps) {
        converged = true;
      }
      old_x[i] = x[i];
    }

    if (converged) {
      break;
    }
  }
}

int main() {
  // Задаем матрицу коэффициентов
  double a[][4] = {
    {15, -4, -6, 5},
    {4, -14, -1, 4},
    {7, -7, 27, -8},
    {-3, -3, 2, -14}
  };

  // Задаем вектор правых частей
  double b[] = {104, 70, 170, 48};

  // Задаем начальное приближение
  double x[] = {0, 0, 0, 0};

  // Задаем точность
  double eps = 0.01;

  // Решаем систему методом Зейделя
  seidel(a, x, b, 4, eps);

  // Выводим результат
  if (converged) {
    cout << "Решение найдено:" << endl;
    for (int i = 0; i < 4; i++) {
      cout << "x[" << i + 1 << "] = " << setprecision(4) << fixed << x[i] << endl;
    }
  } else {
    cout << "Не удалось найти решение с заданной точностью." << endl;
  }

  return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
НОМЕР 4 C++:
#include <iostream>
#include <iomanip>

using namespace std;

void seidel(double a[][4], double x[], double b[], int n, double eps) {
  int i, j;
  double temp;

  for (int it = 0; it < 1000; it++) {
    for (i = 0; i < n; i++) {
      temp = 0;
      for (j = 0; j < n; j++) {
        if (j != i) {
          temp += a[i][j] * x[j];
        }
      }
      x[i] = (b[i] - temp) / a[i][i];

      // Проверка на сходимость
      if (abs(x[i] - old_x[i]) < eps) {
        converged = true;
      }
      old_x[i] = x[i];
    }

    if (converged) {
      break;
    }
  }
}

int main() {
  // Задаем матрицу коэффициентов
  double a[][4] = {
    {12, 15, 14, -6},
    {-3, 11, 18, 8},
    {-2, -16, 27, -9},
    {-4, 9, 17, 3}
  };

  // Задаем вектор правых частей
  double b[] = {45, -155, 11, 53};

  // Задаем начальное приближение
  double x[] = {0, 0, 0, 0};

  // Задаем точность
  double eps = 0.01;

  // Решаем систему методом Зейделя
  seidel(a, x, b, 4, eps);

  // Выводим результат
  if (converged) {
    cout << "Решение найдено:" << endl;
    for (int i = 0; i < 4; i++) {
      cout << "x[" << i + 1 << "] = " << setprecision(4) << fixed << x[i] << endl;
    }
  } else {
    cout << "Не удалось найти решение с заданной точностью." << endl;
  }

  return 0;
}
